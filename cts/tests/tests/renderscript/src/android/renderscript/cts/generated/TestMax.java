/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/generate.sh.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;
import android.renderscript.cts.Target;

import java.util.Arrays;

public class TestMax extends RSBaseCompute {

    private ScriptC_TestMax script;
    private ScriptC_TestMaxRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_TestMax(mRS);
        scriptRelaxed = new ScriptC_TestMaxRelaxed(mRS);
    }

    public class ArgumentsFloatFloatFloat {
        public float inA;
        public float inB;
        public Target.Floaty out;
    }

    private void checkMaxFloatFloatFloat() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xc2162460l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xc2162461l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloatFloatFloat(inA, out);
            verifyResultsMaxFloatFloatFloat(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloatFloatFloat: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloatFloatFloat(inA, out);
            verifyResultsMaxFloatFloatFloat(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloatFloatFloat: " + e.toString());
        }
    }

    private void verifyResultsMaxFloatFloatFloat(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (float) 42);
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (float) 42);
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxFloatFloatFloat" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxFloat2Float2Float2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x36addadal, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x36addadbl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat2Float2Float2(inA, out);
            verifyResultsMaxFloat2Float2Float2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2Float2Float2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat2Float2Float2(inA, out);
            verifyResultsMaxFloat2Float2Float2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2Float2Float2: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat2Float2Float2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (float) 42);
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (float) 42);
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxFloat2Float2Float2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxFloat3Float3Float3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x388bdc7bl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x388bdc7cl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat3Float3Float3(inA, out);
            verifyResultsMaxFloat3Float3Float3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3Float3Float3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat3Float3Float3(inA, out);
            verifyResultsMaxFloat3Float3Float3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3Float3Float3: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat3Float3Float3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (float) 42);
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (float) 42);
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxFloat3Float3Float3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxFloat4Float4Float4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x3a69de1cl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x3a69de1dl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat4Float4Float4(inA, out);
            verifyResultsMaxFloat4Float4Float4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4Float4Float4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat4Float4Float4(inA, out);
            verifyResultsMaxFloat4Float4Float4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4Float4Float4: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat4Float4Float4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (float) 42);
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (float) 42);
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxFloat4Float4Float4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsHalfHalfHalf {
        public short inA;
        public double inADouble;
        public short inB;
        public double inBDouble;
        public Target.Floaty out;
    }

    private void checkMaxHalfHalfHalf() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xb6e25ddbl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xb6e25ddcl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxHalfHalfHalf(inA, out);
            verifyResultsMaxHalfHalfHalf(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalfHalfHalf: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxHalfHalfHalf(inA, out);
            verifyResultsMaxHalfHalfHalf(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalfHalfHalf: " + e.toString());
        }
    }

    private void verifyResultsMaxHalfHalfHalf(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalf args = new ArgumentsHalfHalfHalf();
                args.inA = arrayInA[i];
                args.inADouble = Float16Utils.convertFloat16ToDouble(args.inA);
                args.inB = arrayInB[i];
                args.inBDouble = Float16Utils.convertFloat16ToDouble(args.inB);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxHalfHalfHalf" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxHalf2Half2Half2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0xf8fc6855l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0xf8fc6856l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxHalf2Half2Half2(inA, out);
            verifyResultsMaxHalf2Half2Half2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf2Half2Half2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxHalf2Half2Half2(inA, out);
            verifyResultsMaxHalf2Half2Half2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf2Half2Half2: " + e.toString());
        }
    }

    private void verifyResultsMaxHalf2Half2Half2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalf args = new ArgumentsHalfHalfHalf();
                args.inA = arrayInA[i * 2 + j];
                args.inADouble = Float16Utils.convertFloat16ToDouble(args.inA);
                args.inB = arrayInB[i * 2 + j];
                args.inBDouble = Float16Utils.convertFloat16ToDouble(args.inB);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxHalf2Half2Half2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxHalf3Half3Half3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0x579b7924l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0x579b7925l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxHalf3Half3Half3(inA, out);
            verifyResultsMaxHalf3Half3Half3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf3Half3Half3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxHalf3Half3Half3(inA, out);
            verifyResultsMaxHalf3Half3Half3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf3Half3Half3: " + e.toString());
        }
    }

    private void verifyResultsMaxHalf3Half3Half3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalf args = new ArgumentsHalfHalfHalf();
                args.inA = arrayInA[i * 4 + j];
                args.inADouble = Float16Utils.convertFloat16ToDouble(args.inA);
                args.inB = arrayInB[i * 4 + j];
                args.inBDouble = Float16Utils.convertFloat16ToDouble(args.inB);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxHalf3Half3Half3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxHalf4Half4Half4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0xb63a89f3l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0xb63a89f4l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxHalf4Half4Half4(inA, out);
            verifyResultsMaxHalf4Half4Half4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf4Half4Half4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxHalf4Half4Half4(inA, out);
            verifyResultsMaxHalf4Half4Half4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf4Half4Half4: " + e.toString());
        }
    }

    private void verifyResultsMaxHalf4Half4Half4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalf args = new ArgumentsHalfHalfHalf();
                args.inA = arrayInA[i * 4 + j];
                args.inADouble = Float16Utils.convertFloat16ToDouble(args.inA);
                args.inB = arrayInB[i * 4 + j];
                args.inBDouble = Float16Utils.convertFloat16ToDouble(args.inB);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxHalf4Half4Half4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxFloat2FloatFloat2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x8592438l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x8592439l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat2FloatFloat2(inA, out);
            verifyResultsMaxFloat2FloatFloat2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2FloatFloat2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat2FloatFloat2(inA, out);
            verifyResultsMaxFloat2FloatFloat2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2FloatFloat2: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat2FloatFloat2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (float) 42);
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (float) 42);
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxFloat2FloatFloat2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxFloat3FloatFloat3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0xf6c41894l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xf6c41895l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat3FloatFloat3(inA, out);
            verifyResultsMaxFloat3FloatFloat3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3FloatFloat3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat3FloatFloat3(inA, out);
            verifyResultsMaxFloat3FloatFloat3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3FloatFloat3: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat3FloatFloat3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (float) 42);
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (float) 42);
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxFloat3FloatFloat3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxFloat4FloatFloat4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xe52f0cf0l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xe52f0cf1l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat4FloatFloat4(inA, out);
            verifyResultsMaxFloat4FloatFloat4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4FloatFloat4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat4FloatFloat4(inA, out);
            verifyResultsMaxFloat4FloatFloat4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4FloatFloat4: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat4FloatFloat4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (float) 42);
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (float) 42);
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxFloat4FloatFloat4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxHalf2HalfHalf2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0xf5bbc96fl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xf5bbc970l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxHalf2HalfHalf2(inA, out);
            verifyResultsMaxHalf2HalfHalf2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf2HalfHalf2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxHalf2HalfHalf2(inA, out);
            verifyResultsMaxHalf2HalfHalf2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf2HalfHalf2: " + e.toString());
        }
    }

    private void verifyResultsMaxHalf2HalfHalf2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalf args = new ArgumentsHalfHalfHalf();
                args.inA = arrayInA[i * 2 + j];
                args.inADouble = Float16Utils.convertFloat16ToDouble(args.inA);
                args.inB = arrayInB[i];
                args.inBDouble = Float16Utils.convertFloat16ToDouble(args.inB);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxHalf2HalfHalf2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxHalf3HalfHalf3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0xa8555b13l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xa8555b14l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxHalf3HalfHalf3(inA, out);
            verifyResultsMaxHalf3HalfHalf3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf3HalfHalf3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxHalf3HalfHalf3(inA, out);
            verifyResultsMaxHalf3HalfHalf3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf3HalfHalf3: " + e.toString());
        }
    }

    private void verifyResultsMaxHalf3HalfHalf3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalf args = new ArgumentsHalfHalfHalf();
                args.inA = arrayInA[i * 4 + j];
                args.inADouble = Float16Utils.convertFloat16ToDouble(args.inA);
                args.inB = arrayInB[i];
                args.inBDouble = Float16Utils.convertFloat16ToDouble(args.inB);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxHalf3HalfHalf3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxHalf4HalfHalf4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x5aeeecb7l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x5aeeecb8l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxHalf4HalfHalf4(inA, out);
            verifyResultsMaxHalf4HalfHalf4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf4HalfHalf4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxHalf4HalfHalf4(inA, out);
            verifyResultsMaxHalf4HalfHalf4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxHalf4HalfHalf4: " + e.toString());
        }
    }

    private void verifyResultsMaxHalf4HalfHalf4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalf args = new ArgumentsHalfHalfHalf();
                args.inA = arrayInA[i * 4 + j];
                args.inADouble = Float16Utils.convertFloat16ToDouble(args.inA);
                args.inB = arrayInB[i];
                args.inBDouble = Float16Utils.convertFloat16ToDouble(args.inB);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxHalf4HalfHalf4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsCharCharChar {
        public byte inA;
        public byte inB;
        public byte out;
    }

    private void checkMaxCharCharChar() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xb6405876l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xb6405877l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxCharCharChar(inA, out);
            verifyResultsMaxCharCharChar(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxCharCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxCharCharChar(inA, out);
            verifyResultsMaxCharCharChar(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxCharCharChar: " + e.toString());
        }
    }

    private void verifyResultsMaxCharCharChar(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxCharCharChar" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxChar2Char2Char2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x19e42804l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x19e42805l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxChar2Char2Char2(inA, out);
            verifyResultsMaxChar2Char2Char2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar2Char2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxChar2Char2Char2(inA, out);
            verifyResultsMaxChar2Char2Char2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar2Char2Char2: " + e.toString());
        }
    }

    private void verifyResultsMaxChar2Char2Char2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxChar2Char2Char2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxChar3Char3Char3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x788338d3l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x788338d4l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxChar3Char3Char3(inA, out);
            verifyResultsMaxChar3Char3Char3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar3Char3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxChar3Char3Char3(inA, out);
            verifyResultsMaxChar3Char3Char3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar3Char3Char3: " + e.toString());
        }
    }

    private void verifyResultsMaxChar3Char3Char3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxChar3Char3Char3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxChar4Char4Char4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xd72249a2l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xd72249a3l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxChar4Char4Char4(inA, out);
            verifyResultsMaxChar4Char4Char4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar4Char4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxChar4Char4Char4(inA, out);
            verifyResultsMaxChar4Char4Char4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar4Char4Char4: " + e.toString());
        }
    }

    private void verifyResultsMaxChar4Char4Char4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxChar4Char4Char4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUcharUcharUchar {
        public byte inA;
        public byte inB;
        public byte out;
    }

    private void checkMaxUcharUcharUchar() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x853a162dl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x853a162el, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUcharUcharUchar(inA, out);
            verifyResultsMaxUcharUcharUchar(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUcharUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUcharUcharUchar(inA, out);
            verifyResultsMaxUcharUcharUchar(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUcharUcharUchar: " + e.toString());
        }
    }

    private void verifyResultsMaxUcharUcharUchar(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUcharUcharUchar" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUchar2Uchar2Uchar2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xb7e9a9dbl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xb7e9a9dcl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUchar2Uchar2Uchar2(inA, out);
            verifyResultsMaxUchar2Uchar2Uchar2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar2Uchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUchar2Uchar2Uchar2(inA, out);
            verifyResultsMaxUchar2Uchar2Uchar2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar2Uchar2Uchar2: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar2Uchar2Uchar2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUchar2Uchar2Uchar2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUchar3Uchar3Uchar3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0xb9c7ab7cl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0xb9c7ab7dl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUchar3Uchar3Uchar3(inA, out);
            verifyResultsMaxUchar3Uchar3Uchar3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar3Uchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUchar3Uchar3Uchar3(inA, out);
            verifyResultsMaxUchar3Uchar3Uchar3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar3Uchar3Uchar3: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar3Uchar3Uchar3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUchar3Uchar3Uchar3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUchar4Uchar4Uchar4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0xbba5ad1dl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0xbba5ad1el, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUchar4Uchar4Uchar4(inA, out);
            verifyResultsMaxUchar4Uchar4Uchar4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar4Uchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUchar4Uchar4Uchar4(inA, out);
            verifyResultsMaxUchar4Uchar4Uchar4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar4Uchar4Uchar4: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar4Uchar4Uchar4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (byte) 42);
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (byte) 42);
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUchar4Uchar4Uchar4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsShortShortShort {
        public short inA;
        public short inB;
        public short out;
    }

    private void checkMaxShortShortShort() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x43b57294l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x43b57295l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShortShortShort(inA, out);
            verifyResultsMaxShortShortShort(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShortShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShortShortShort(inA, out);
            verifyResultsMaxShortShortShort(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShortShortShort: " + e.toString());
        }
    }

    private void verifyResultsMaxShortShortShort(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxShortShortShort" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxShort2Short2Short2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x56ecb9del, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x56ecb9dfl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShort2Short2Short2(inA, out);
            verifyResultsMaxShort2Short2Short2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort2Short2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShort2Short2Short2(inA, out);
            verifyResultsMaxShort2Short2Short2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort2Short2Short2: " + e.toString());
        }
    }

    private void verifyResultsMaxShort2Short2Short2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxShort2Short2Short2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxShort3Short3Short3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x58cabb7fl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x58cabb80l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShort3Short3Short3(inA, out);
            verifyResultsMaxShort3Short3Short3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort3Short3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShort3Short3Short3(inA, out);
            verifyResultsMaxShort3Short3Short3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort3Short3Short3: " + e.toString());
        }
    }

    private void verifyResultsMaxShort3Short3Short3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxShort3Short3Short3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxShort4Short4Short4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x5aa8bd20l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x5aa8bd21l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShort4Short4Short4(inA, out);
            verifyResultsMaxShort4Short4Short4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort4Short4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShort4Short4Short4(inA, out);
            verifyResultsMaxShort4Short4Short4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort4Short4Short4: " + e.toString());
        }
    }

    private void verifyResultsMaxShort4Short4Short4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxShort4Short4Short4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUshortUshortUshort {
        public short inA;
        public short inB;
        public short out;
    }

    private void checkMaxUshortUshortUshort() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xb947704bl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xb947704cl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshortUshortUshort(inA, out);
            verifyResultsMaxUshortUshortUshort(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshortUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshortUshortUshort(inA, out);
            verifyResultsMaxUshortUshortUshort(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshortUshortUshort: " + e.toString());
        }
    }

    private void verifyResultsMaxUshortUshortUshort(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUshortUshortUshort" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUshort2Ushort2Ushort2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x150b1f95l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x150b1f96l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshort2Ushort2Ushort2(inA, out);
            verifyResultsMaxUshort2Ushort2Ushort2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort2Ushort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshort2Ushort2Ushort2(inA, out);
            verifyResultsMaxUshort2Ushort2Ushort2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort2Ushort2Ushort2: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort2Ushort2Ushort2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUshort2Ushort2Ushort2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUshort3Ushort3Ushort3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x5df0112cl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x5df0112dl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshort3Ushort3Ushort3(inA, out);
            verifyResultsMaxUshort3Ushort3Ushort3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort3Ushort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshort3Ushort3Ushort3(inA, out);
            verifyResultsMaxUshort3Ushort3Ushort3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort3Ushort3Ushort3: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort3Ushort3Ushort3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUshort3Ushort3Ushort3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUshort4Ushort4Ushort4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xa6d502c3l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xa6d502c4l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshort4Ushort4Ushort4(inA, out);
            verifyResultsMaxUshort4Ushort4Ushort4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort4Ushort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshort4Ushort4Ushort4(inA, out);
            verifyResultsMaxUshort4Ushort4Ushort4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort4Ushort4Ushort4: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort4Ushort4Ushort4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (short) 42);
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (short) 42);
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUshort4Ushort4Ushort4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsIntIntInt {
        public int inA;
        public int inB;
        public int out;
    }

    private void checkMaxIntIntInt() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xe43d0fa9l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xe43d0faal, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxIntIntInt(inA, out);
            verifyResultsMaxIntIntInt(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxIntIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxIntIntInt(inA, out);
            verifyResultsMaxIntIntInt(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxIntIntInt: " + e.toString());
        }
    }

    private void verifyResultsMaxIntIntInt(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxIntIntInt" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxInt2Int2Int2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0xbb9dccd7l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0xbb9dccd8l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxInt2Int2Int2(inA, out);
            verifyResultsMaxInt2Int2Int2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt2Int2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxInt2Int2Int2(inA, out);
            verifyResultsMaxInt2Int2Int2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt2Int2Int2: " + e.toString());
        }
    }

    private void verifyResultsMaxInt2Int2Int2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxInt2Int2Int2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxInt3Int3Int3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x867314c0l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x867314c1l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxInt3Int3Int3(inA, out);
            verifyResultsMaxInt3Int3Int3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt3Int3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxInt3Int3Int3(inA, out);
            verifyResultsMaxInt3Int3Int3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt3Int3Int3: " + e.toString());
        }
    }

    private void verifyResultsMaxInt3Int3Int3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxInt3Int3Int3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxInt4Int4Int4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x51485ca9l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x51485caal, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxInt4Int4Int4(inA, out);
            verifyResultsMaxInt4Int4Int4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt4Int4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxInt4Int4Int4(inA, out);
            verifyResultsMaxInt4Int4Int4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt4Int4Int4: " + e.toString());
        }
    }

    private void verifyResultsMaxInt4Int4Int4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxInt4Int4Int4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUintUintUint {
        public int inA;
        public int inB;
        public int out;
    }

    private void checkMaxUintUintUint() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x85f73e36l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x85f73e37l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUintUintUint(inA, out);
            verifyResultsMaxUintUintUint(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUintUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUintUintUint(inA, out);
            verifyResultsMaxUintUintUint(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUintUintUint: " + e.toString());
        }
    }

    private void verifyResultsMaxUintUintUint(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUintUintUint" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUint2Uint2Uint2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xe84d6c4l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xe84d6c5l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUint2Uint2Uint2(inA, out);
            verifyResultsMaxUint2Uint2Uint2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint2Uint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUint2Uint2Uint2(inA, out);
            verifyResultsMaxUint2Uint2Uint2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint2Uint2Uint2: " + e.toString());
        }
    }

    private void verifyResultsMaxUint2Uint2Uint2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUint2Uint2Uint2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUint3Uint3Uint3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x6d23e793l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x6d23e794l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUint3Uint3Uint3(inA, out);
            verifyResultsMaxUint3Uint3Uint3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint3Uint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUint3Uint3Uint3(inA, out);
            verifyResultsMaxUint3Uint3Uint3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint3Uint3Uint3: " + e.toString());
        }
    }

    private void verifyResultsMaxUint3Uint3Uint3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUint3Uint3Uint3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUint4Uint4Uint4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0xcbc2f862l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0xcbc2f863l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUint4Uint4Uint4(inA, out);
            verifyResultsMaxUint4Uint4Uint4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint4Uint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUint4Uint4Uint4(inA, out);
            verifyResultsMaxUint4Uint4Uint4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint4Uint4Uint4: " + e.toString());
        }
    }

    private void verifyResultsMaxUint4Uint4Uint4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (int) 42);
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (int) 42);
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUint4Uint4Uint4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsLongLongLong {
        public long inA;
        public long inB;
        public long out;
    }

    private void checkMaxLongLongLong() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x85eceb84l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x85eceb85l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLongLongLong(inA, out);
            verifyResultsMaxLongLongLong(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLongLongLong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLongLongLong(inA, out);
            verifyResultsMaxLongLongLong(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLongLongLong: " + e.toString());
        }
    }

    private void verifyResultsMaxLongLongLong(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxLongLongLong" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxLong2Long2Long2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xc249c9dal, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xc249c9dbl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLong2Long2Long2(inA, out);
            verifyResultsMaxLong2Long2Long2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong2Long2Long2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLong2Long2Long2(inA, out);
            verifyResultsMaxLong2Long2Long2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong2Long2Long2: " + e.toString());
        }
    }

    private void verifyResultsMaxLong2Long2Long2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxLong2Long2Long2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxLong3Long3Long3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x20e8daa9l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x20e8daaal, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLong3Long3Long3(inA, out);
            verifyResultsMaxLong3Long3Long3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong3Long3Long3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLong3Long3Long3(inA, out);
            verifyResultsMaxLong3Long3Long3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong3Long3Long3: " + e.toString());
        }
    }

    private void verifyResultsMaxLong3Long3Long3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxLong3Long3Long3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxLong4Long4Long4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x7f87eb78l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x7f87eb79l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLong4Long4Long4(inA, out);
            verifyResultsMaxLong4Long4Long4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong4Long4Long4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLong4Long4Long4(inA, out);
            verifyResultsMaxLong4Long4Long4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong4Long4Long4: " + e.toString());
        }
    }

    private void verifyResultsMaxLong4Long4Long4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxLong4Long4Long4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUlongUlongUlong {
        public long inA;
        public long inB;
        public long out;
    }

    private void checkMaxUlongUlongUlong() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x8f18baafl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x8f18bab0l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlongUlongUlong(inA, out);
            verifyResultsMaxUlongUlongUlong(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlongUlongUlong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlongUlongUlong(inA, out);
            verifyResultsMaxUlongUlongUlong(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlongUlongUlong: " + e.toString());
        }
    }

    private void verifyResultsMaxUlongUlongUlong(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUlongUlongUlong" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUlong2Ulong2Ulong2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0x5946bc65l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0x5946bc66l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlong2Ulong2Ulong2(inA, out);
            verifyResultsMaxUlong2Ulong2Ulong2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong2Ulong2Ulong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlong2Ulong2Ulong2(inA, out);
            verifyResultsMaxUlong2Ulong2Ulong2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong2Ulong2Ulong2: " + e.toString());
        }
    }

    private void verifyResultsMaxUlong2Ulong2Ulong2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUlong2Ulong2Ulong2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUlong3Ulong3Ulong3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x5b24be06l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x5b24be07l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlong3Ulong3Ulong3(inA, out);
            verifyResultsMaxUlong3Ulong3Ulong3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong3Ulong3Ulong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlong3Ulong3Ulong3(inA, out);
            verifyResultsMaxUlong3Ulong3Ulong3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong3Ulong3Ulong3: " + e.toString());
        }
    }

    private void verifyResultsMaxUlong3Ulong3Ulong3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUlong3Ulong3Ulong3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkMaxUlong4Ulong4Ulong4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x5d02bfa7l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x5d02bfa8l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlong4Ulong4Ulong4(inA, out);
            verifyResultsMaxUlong4Ulong4Ulong4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong4Ulong4Ulong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlong4Ulong4Ulong4(inA, out);
            verifyResultsMaxUlong4Ulong4Ulong4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong4Ulong4Ulong4: " + e.toString());
        }
    }

    private void verifyResultsMaxUlong4Ulong4Ulong4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInA, (long) 42);
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInB, (long) 42);
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inA: ");
                        appendVariableToMessage(message, args.inA);
                        message.append("\n");
                        message.append("Input inB: ");
                        appendVariableToMessage(message, args.inB);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkMaxUlong4Ulong4Ulong4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public void testMax() {
        checkMaxFloatFloatFloat();
        checkMaxFloat2Float2Float2();
        checkMaxFloat3Float3Float3();
        checkMaxFloat4Float4Float4();
        checkMaxHalfHalfHalf();
        checkMaxHalf2Half2Half2();
        checkMaxHalf3Half3Half3();
        checkMaxHalf4Half4Half4();
        checkMaxFloat2FloatFloat2();
        checkMaxFloat3FloatFloat3();
        checkMaxFloat4FloatFloat4();
        checkMaxHalf2HalfHalf2();
        checkMaxHalf3HalfHalf3();
        checkMaxHalf4HalfHalf4();
        checkMaxCharCharChar();
        checkMaxChar2Char2Char2();
        checkMaxChar3Char3Char3();
        checkMaxChar4Char4Char4();
        checkMaxUcharUcharUchar();
        checkMaxUchar2Uchar2Uchar2();
        checkMaxUchar3Uchar3Uchar3();
        checkMaxUchar4Uchar4Uchar4();
        checkMaxShortShortShort();
        checkMaxShort2Short2Short2();
        checkMaxShort3Short3Short3();
        checkMaxShort4Short4Short4();
        checkMaxUshortUshortUshort();
        checkMaxUshort2Ushort2Ushort2();
        checkMaxUshort3Ushort3Ushort3();
        checkMaxUshort4Ushort4Ushort4();
        checkMaxIntIntInt();
        checkMaxInt2Int2Int2();
        checkMaxInt3Int3Int3();
        checkMaxInt4Int4Int4();
        checkMaxUintUintUint();
        checkMaxUint2Uint2Uint2();
        checkMaxUint3Uint3Uint3();
        checkMaxUint4Uint4Uint4();
        checkMaxLongLongLong();
        checkMaxLong2Long2Long2();
        checkMaxLong3Long3Long3();
        checkMaxLong4Long4Long4();
        checkMaxUlongUlongUlong();
        checkMaxUlong2Ulong2Ulong2();
        checkMaxUlong3Ulong3Ulong3();
        checkMaxUlong4Ulong4Ulong4();
    }
}
